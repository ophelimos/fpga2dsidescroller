{\rtf1\ansi\deff1\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Luxi Sans;}{\f1\fswiss\fprq2\fcharset0 Arial;}{\f2\froman\fprq2\fcharset0 Times{\*\falt Times New Roman};}{\f3\fswiss\fprq2\fcharset0 Arial;}{\f4\fswiss\fprq2\fcharset0 Luxi Sans;}{\f5\froman\fprq2\fcharset0 Luxi Sans;}{\f6\fswiss\fprq2\fcharset2 Luxi Sans;}{\f7\froman\fprq2\fcharset128 Times New Roman;}{\f8\froman\fprq2\fcharset128 Times New Roman;}{\f9\fnil\fprq0\fcharset0 Tahoma;}{\f10\fswiss\fprq2\fcharset0 Tahoma;}{\f11\fswiss\fprq0\fcharset0 Tahoma;}}
{\colortbl;\red0\green0\blue0;\red128\green128\blue128;}
{\stylesheet{\s1\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\snext1 Normal;}
{\s2\sb240\sa120\keepn\rtlch\af10\afs28\lang255\ltrch\dbch\af4\langfe255\hich\f4\fs28\lang1033\loch\f4\fs28\lang1033\sbasedon1\snext3 Heading;}
{\s3\sa120\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\sbasedon1\snext3 Body Text;}
{\s4\sa120\rtlch\af11\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\sbasedon3\snext4 List;}
{\s5\sb120\sa120\rtlch\af9\afs24\lang255\ai\ltrch\dbch\langfe255\hich\fs24\lang1033\i\loch\fs24\lang1033\i\sbasedon1\snext5 caption;}
{\s6\rtlch\af11\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\sbasedon1\snext6 Index;}
{\s7\sb120\sa120\rtlch\af11\afs24\lang255\ai\ltrch\dbch\langfe255\hich\fs24\lang1033\i\loch\fs24\lang1033\i\sbasedon1\snext7 caption;}
{\s8\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\snext1 heading 1;}
{\s9\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\snext1 heading 2;}
{\s10\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\snext1 heading 3;}
{\s11\rtlch\afs24\lang255\ltrch\dbch\langfe255\hich\fs24\lang1033\loch\fs24\lang1033\snext1 heading 4;}
{\*\cs13\cf0\rtlch\af1\afs24\lang255\ltrch\dbch\af1\langfe255\hich\f1\fs24\lang1033\loch\f1\fs24\lang1033 Numbering Symbols;}
}
{\info{\creatim\yr2008\mo12\dy3\hr14\min6}{\revtim\yr2008\mo12\dy3\hr14\min47}{\printim\yr1601\mo1\dy1\hr0\min0}{\comment StarWriter}{\vern6800}}\deftab709
{\*\pgdsctbl
{\pgdsc0\pgdscuse195\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\pgdscnxt0 Standard;}}
{\*\pgdscno0}\paperh15840\paperw12240\margl1800\margr1800\margt1440\margb1440\sectd\sbknone\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pard\plain \ltrpar\s1\sa120\ql\rtlch\af2\afs32\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs32\lang1033\b\loch\f8\fs32\lang1033\b {\rtlch \ltrch\loch\f8\fs32\lang1033\i0\b 1  Introduction:}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 The motivation for our project was to recreate a rendition of the classic Super Mario Brothers games.  This involves a two-dimensional scrolling-level based game, where a character traverses a level while avoiding obstacles such as enemies and bottomless p
its.  Scoring is based on both the time taken to complete the level, and in-game modifiers such as coins.}
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 For our ECE 241 project, we wanted to implement this sort of game on the DE2 board. There were two big reasons for this: first, Nintendo\u8217\'19s Super Mario was a game that we had both enjoyed as kids, and secondly, it conformed well to the spiral development mo
del, allowing more complicated bits to be built on a baseline.}
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 We realized at the beginning that this was an ambitious project, and that we wouldn't be able to completely replicate all of the games features within our three week development time. Thus, we decided upon the various elements we wanted to create (and thos
e to exclude), and came up with some milestones and a rough timeline. We identified three major subgoals, each building on top of the previous: the creation of a tile-based side-scrolling background, the creation of a character able to run and jump within 
this tile-based world, and the creation of enemies and items this character would be able to interact with.}
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 
\par \pard\plain \ltrpar\s1\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Unfortunately, due to time constraints and unforeseen bugs, while a working tile-based side-scrolling background was finished, the character's ability to interact with the tile-based world was only partially completed, and items and enemies weren't at all.
 As a result, during this report we will explain two things: what the circuit as presented is able to do, and what the circuit was intended to do.}
\par \pard\plain \ltrpar\s9\sb240\sa60\keepn\ql\rtlch\af2\afs32\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs32\lang1033\b\loch\f8\fs32\lang1033\b {\rtlch \ltrch\loch\f8\fs32\lang1033\i0\b 2  The Design:}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.1  main_state_machine:}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Our base module, main_state_machine controls program flow by means of a state machine. Using a simple enable-done handshake, it sequentially passes control to drawBackground, drawSprite, detectCollision, and the movement modules, in a continuous loop. As w
ell, to slow down execution, it contains a wait state, which ensures that each loop takes no less than 1/60th of a second. Although not implemented in the final design, it was also intended to travel to ending states when the game was won or lost, where it
 would stay until reset.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.2  drawBackground}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 DrawBackground sequentially reads in a pixel from the levelmap, tells drawTile to draw the corresponding tile on the screen, and then advances to the next pixel after drawTile has reported success. After the entire screen has been drawn, it raises the done
 flag, and waits until it is enabled again. We simulate movement by changing the offset value at which drawBackground begins reading from the levelmap. Although we intended to implement per-pixel offsets, this was still buggy at time of presentation, and c
urrently, the background moves one tile at a time.}
\par \pard\plain \ltrpar\s11\sb240\sa60\keepn\ql\rtlch\af2\afs24\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b 2.2.1  drawTile}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Once enabled, drawTile reads in 9-bit (RGB333) color values and outputs them to the VGA adapter, drawing an 8x8 tile starting from the position it was given by drawBackground. Since all the tiles are stored within a single memory file, a specific tile is a
ccessed by offsetting the memory counter according to the tile code sent by drawBackground.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.3  drawSprite}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 DrawSprite, following the pattern of our other draw modules, reads in a value from memory and draws it on the screen, painting on top of the background. DrawSprite differs however in that it is pixel-based, not tile-based, and can draw a sprite of up to 32
x32 pixels anywhere on the screen. A specific animation step is decided by offsetting the memory counter with an external input (see spriteMem).}
\par \pard\plain \ltrpar\s11\sb240\sa60\keepn\ql\rtlch\af2\afs24\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b 2.3.1  spriteMem}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 DrawSprite was designed to be capable of drawing up to four different 32x32 pixel sprites, each with four animation steps. Each sprite is preloaded into a memory block, with the MIF containing up to four sequential images corresponding to different frames 
of animation. The width and height of the four images, as well as the number of sequential images is hard-coded in a register. To implement the character drawing function, we preloaded the memory with a MIF file containing four images of the character in d
ifferent positions, and set the register values to the appropriate width, height, and number of animation frames (8, 16, 4, respectively). While only one 8x16 character sprite is implemented, spriteMem is a memory abstraction layer which is capable of pull
ing the appropriate image from memory (again using offsets), and sending it to drawSprite. The remaining three sprite memory blocks were to be used by enemies.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.4  drawScreen}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Not present in the final design, drawScreen is an extension of the drawTile module, allowing the entire screen at once to be drawn from memory, for use in implementing customized beginning, death, and ending screens.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.5  Movement}
\par \pard\plain \ltrpar\s11\sb240\sa60\keepn\ql\rtlch\af2\afs24\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b 2.5.1  detectCollision}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 To prevent movement in blocked directions, detectCollision would take in the current character position, read in adjacent tiles from the tilemap, and use that to determine whether or not the character would be allowed to move in a certain direction. The ou
tput given is four signals representing an obstruction in front, behind, above, or below the input position. As implemented, all tiles except the sky tile caused a block signal, but this is easily modifiable, allowing different types of non-blocking tiles 
to be added as necessary.}
\par \pard\plain \ltrpar\s11\sb240\sa60\keepn\ql\rtlch\af2\afs24\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b 2.5.2  levelMovement}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Not a separate module, but instead a section within main_state_machine, we implemented an up-down counter that, in response to push keys, would either increment or decrement, changing the background offset, and in essence, move the character horizontally a
cross the level.}
\par \pard\plain \ltrpar\s11\sb240\sa60\keepn\ql\rtlch\af2\afs24\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b 2.5.3  characterMovement}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 A source of great frustration, characterMovement was intended to control the falling and jumping activities of the character. It was intended that a register would hold the y-position of the character, and would be constantly decremented to simulate fallin
g, unless of course the character was blocked beneath. Jumping would consist of adding the output of a time-decrementing counter to the y-position register. Unfortunately, characterMovement was still buggy when we ran out of time, and instead, up-down char
acter movement was implemented by an updown counter within main_state_machine, just like levelMovement.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.6  Scoring}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Scoring, as implemented, is a second-by-second counter that outputs a decimal number to the hex displays. Since there is no ending to the game as implemented, the counter effectively counts up indefinitely from each reset.}
\par \pard\plain \ltrpar\s10\sb240\sa60\keepn\ql\rtlch\af2\afs28\lang255\ab\ltrch\dbch\af2\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 2.7  bmp2mif}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Although not{\*\bkmkstart DDE_LINK} properly pa{\*\bkmkend DDE_LINK}rt of the circuit, it should be mentioned that we modified and extended the bmp2mif code to create 9-bit and 4-bit MIF files, which were used for our tiles and tilemap respectively.  By increasing the bit-depth of the MIF files, we 
were able to support vibrant 512-colour tiles, as well as up to 16 different types of tiles.  The design as presented, however, only made use of 8 different tiles.}
\par \pard\plain \ltrpar\s10\qj\sb240\sa60\keepn\rtlch\afs28\lang255\ltrch\dbch\langfe255\hich\fs28\lang1033\loch\fs28\lang1033{\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b\f8{\b 2.8  Block Diagram}}{\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b0\f8{\b0\fs24  \u8211\'13 on separate page}}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs32\lang255\ab\ltrch\dbch\af5\langfe255\hich\f8\fs32\lang1033\b\loch\f8\fs32\lang1033\b {\rtlch \ltrch\loch\f8\fs32\lang1033\i0\b 3  Report on Success:}
\par \pard\plain \ltrpar\s1\qj\sb60\rtlch\af5\afs32\lang255\ab\ltrch\dbch\af5\langfe255\hich\f8\fs32\lang1033\b\loch\f8\fs32\lang1033\b 
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af7\afs28\lang255\ab\ltrch\dbch\af7\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 3.1 Level Drawing and Scrolling}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 We were able to complete this fundamental project milestone. Since this code would form the backbone of our project, it was important that level drawing and scrolling functioned properly and without bugs.  We were able to load the level tilemap from memory
, and based on the value of our position counter, draw the appropriate tiles on the screen. By pressing the keys on the DE2, it was possible to scroll the level, tile by tile, both forwards and backwards, simulating character movement.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 A possible next step in terms of level scrolling would be to scroll pixel by pixel instead of tile by tile (which meant that the level essentially scrolled 8 pixels at a time). This would have improved the appearance of the scrolling animation, and also gi
ven the level a higher physical resolution in terms of the character's position. Although code was written to perform this functionality, we were unable to fully debug it in time for the final presentation. We speculate that the root cause of the bugs was 
due to incompatibilities between our screen drawing algorithm and pixel-based scrolling.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af7\afs24\lang255\ab\ltrch\dbch\af7\langfe255\hich\f8\fs24\lang1033\b\loch\f8\fs24\lang1033\b{\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b\fs28 3.2 Character Movement and Level Traversal}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 The next milestone in our timeline was to allow character movement and level traversal. This meant the ability to jump over obstacles, move across the level, and be subject to an imposed gravity. In addition, it was necessary to draw the character on the s
creen.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 The first two tasks were achieved, however we couldn't get gravity modeling to work. Thus, the character was able to move across the screen in all four directions, but wouldn't fall to the ground after jumping. The mostly likely cause of this is a faulty s
tate machine within the characterMovement module, which was to control the character's Y position.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af7\afs28\lang255\ab\ltrch\dbch\af7\langfe255\hich\f8\fs28\lang1033\b\loch\f8\fs28\lang1033\b {\rtlch \ltrch\loch\f8\fs28\lang1033\i0\b 3.3 Enemies, Items, and other Fancy Features}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Essentially, we were able to write the code for most of the features listed in the milestones, but despite the fact that many of our individual modules seemed to work properly in simulation, they failed when connected to the main state machine for testing 
on the DE2.  Ultimately, we ran out of time: we had the code, but we just didn't have enough time to fix all the bugs.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Of the features that we planned for the third milestone, we were only able to get character animation working. That is, the character could face both left and right, and had two animation states: jumping and standing. Pressing the left and right keys would
 determine the direction the character was facing, and whether or not a jumping animation was shown was determined by whether or not the character was standing on a tile.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 We had also planned introduction, win, and lose screens, which would have been shown at the start and end of the game. Unfortunately, despite the fact drawScreen was written, and we had screens prepared, we simply ran out of time.  Although merging these f
unctions should have been trivial, it simply was another casualty of the time crunch.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af7\afs32\lang255\ab\ltrch\dbch\af7\langfe255\hich\f8\fs32\lang1033\b\loch\f8\fs32\lang1033\b {\rtlch \ltrch\loch\f8\fs32\lang1033\i0\b 4  Conclusions}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Before we even started coding, we did a lot of planning: we decided what needed to be done, how it was going to be done, and when it was going to be done by.  A lot of this was very helpful: setting up a subversion repository on googlecode meant that we di
dn't trample on each other's changes, and by modularizing the majority of our design, things were a lot easier to separate out and debug.  However, we did make one mistake in our planning: it was said in lecture that to set deadlines, you should take the a
mount of time you think it'll take, and then double it.  We forgot to double our expected time.  As a result, we ended up with a project that did about half of what we wanted it to.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 Why did it take roughly twice as long?  Because we forgot to take bugs into account.  As an old programming joke goes, \u8220\'1cYou spend 90% of your time writing the code, and then you spend the other 90% of your time fixing the bugs.\u8221\'1d  For all the time we spent 
actually writing code, we easily spent all that time again trying to fix the bugs in it, and had multiple lab sessions where we pretty much did nothing but spend hours trying to track down bugs in our code.  And not only that, but doing so inefficiently.  
That, as it turned out was the real problem.}
\par \pard\plain \ltrpar\s1\sa120\ql\rtlch\af6\afs24\lang255\ltrch\dbch\af6\langfe255\hich\f8\fs24\lang1033\loch\f8\fs24\lang1033 {\rtlch \ltrch\loch\f8\fs24\lang1033\i0\b0 If we were going to do it again, the largest thing I would chance is how we fixed bugs.  Rather than making a small bug-fix, then going through the entire compile process and programming it into the DE2, it turned out that it was usually a lot more effecti
ve to separate out the portion that was causing problems into a separate module (if it wasn't already), simulate just that portion, and figure it out from there.}
\par }