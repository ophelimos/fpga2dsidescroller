{\rtf1\ansi\ansicpg1252\deff0\deftab709{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Times;}{\f2\froman\fprq2\fcharset0 Luxi Sans;}{\f3\froman\fprq2\fcharset0 Times New Roman;}{\f4\fswiss\fprq2\fcharset2 Luxi Sans;}{\f5\froman\fprq2\fcharset128 Times New Roman;}}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}{\s4 heading 4;}}
{\*\generator Msftedit 5.41.21.2508;}\viewkind4\uc1\pard\sa120\lang1033\f0\fs20 The report should be a maximum 5 pages; not including schematics and Verilog Code. In addition, the report should contain these Sections: \line 1. Introduction \line\endash  English description of goals of project; motivation \line\line 2. The Design \line\endash  Block Diagram of the major parts, and of sub-parts as necessary \line\endash  English description of the function of each part \line\endash  Be sure to start from top and go down. (not bottom up!) \line\line 3. Report on Success \line\endash  Did it work? Show pictures or describe \line\endash  For parts that didn\rquote t work \endash  speculate as to why \line\line 4. What would you do differently if you were going to start all over again - i.e. what did you learn? \line\line Appendix: All Verilog Code and Schematics\par
\par
--------\par
\pard\nowidctlpar\sa120\b\f1\fs32 1  Introduction:\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24\par
\pard\nowidctlpar The motivation for our project was to recreate a rendition of the classic Super Mario Brothers games.  This involves a two-dimensional scrolling-level based game, where a character traverses a level, avoiding obstacles, with the purpose of reaching the end. A score is calculated based on the time taken to complete the level. There may also be some in-game modifiers, such as coins, which can be picked up while playing the level to increase the score. To make the gameplay more challenging, enemies also populate the level, and must be avoided as touching one of them means losing the game.\par
\par
For our ECE 241 project, we wanted to implement this sort of game on the DE2 board. There were two big reasons for this: first, Nintendo\rquote s Super Mario was a game that we had both enjoyed as kids, and secondly, it conformed well to the spiral development model, allowing more complicated bits to be built on a baseline.\par
\par
We realized at the beginning that this was an ambitious project, and that we wouldn't be able to completely replicate all of the games features because of our three week development time. Thus, we decided upon the various elements we wanted to create (and those to exclude), and came up with some milestones and a rough timeline. We identified three major subgoals, each building on top of the previous: the creation of a tile-based side-scrolling background, the creation of a character able to run and jump within this tile-based world, and the creation of enemies and items this character would be able to interact with.\par
\par
Unfortunately, due to time constraints and unforeseen bugs, while a working tile-based side-scrolling background was finished, the character's ability to interact with the tile-based world was only partially completed, and items and enemies weren't at all. As a result, during this report we will explain two things: what the circuit as presented is able to do, and what the circuit was intended to do.\par
\pard\keepn\nowidctlpar\s2\sb240\sa60\b\f1\fs32 2  The Design:\par
\pard\keepn\nowidctlpar\s3\sb240\sa60 2.1  main_state_machine:\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 Our base module, main_state_machine controls program flow by means of a state machine. Using a simple enable-done handshake, it sequentially passes control to drawBackground, drawSprite, detectCollision, and the movement modules, in a continuous loop. As well, to slow down execution, it contains a wait state, which ensures that each loop takes no less than 1/60th of a second. Although not implemented in the final design, it was also intended to travel to ending states when the game was won or lost, where it would stay until reset.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.2  drawBackground\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 DrawBackground sequentially reads in a pixel from the levelmap, tells drawTile to draw the corresponding tile on the screen, and then advances to the next pixel after drawTile has reported success. After the entire screen has been drawn, it raises the done flag, and waits until it is enabled again. We simulate movement by changing the offset value at which drawBackground begins reading from the levelmap. Although we intended to implement per-pixel offsets, this was still buggy at time of presentation, and currently, the background moves one tile at a time.\par
\pard\keepn\nowidctlpar\s4\sb240\sa60\b\f1 2.2.1  drawTile\par
\pard\nowidctlpar\sb60\qj\b0\f2 Once enabled, drawTile reads in 9-bit (RGB333) color values and outputs them to the VGA adapter, drawing an 8x8 tile starting from the position it was given by drawBackground. Since all the tiles are stored within a single memory file, a specific tile is accessed by offsetting the memory counter according to the tile code sent by drawBackground.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.3  drawSprite\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 DrawSprite, following the pattern of our other draw modules, reads in a value from memory and draws it on the screen, painting on top of the background. DrawSprite differs however in that it is pixel-based, not tile-based, and can draw a sprite of up to 32x32 pixels anywhere on the screen. A specific animation step is decided by offsetting the memory counter with an external input (see spriteMem).\par
\pard\keepn\nowidctlpar\s4\sb240\sa60\b\f1 2.3.1  spriteMem\par
\pard\nowidctlpar\sb60\qj\b0\f2 DrawSprite was designed to be capable of drawing up to four different 32x32 pixel sprites, each with four animation steps. Each sprite is preloaded into a memory block, with the MIF containing up to four sequential images corresponding to different frames of animation. The width and height of the four images, as well as the number of sequential images is hard-coded in a register. To implement the character drawing function, we preloaded the memory with a MIF file containing four images of the character in different positions, and set the register values to the appropriate width, height, and number of animation frames (8, 16, 4, respectively). While only one 8x16 character sprite is implemented, spriteMem is a memory abstraction layer which is capable of pulling the appropriate image from memory (again using offsets), and sending it to drawSprite. The remaining three sprite memory blocks were to be used by enemies.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.4  drawScreen\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 Not present in the final design, drawScreen is an extension of the drawTile module, allowing the entire screen at once to be drawn from memory, for use in implementing customized beginning, death, and ending screens.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.5  Movement\par
\pard\keepn\nowidctlpar\s4\sb240\sa60\fs24 2.5.1  detectCollision\par
\pard\nowidctlpar\sb60\qj\b0\f2 To prevent movement in blocked directions, detectCollision would take in the current character position, read in adjacent tiles from the tilemap, and use that to determine whether or not the character would be allowed to move in a certain direction. The output given is four signals representing an obstruction in front, behind, above, or below the input position. As implemented, all tiles except the sky tile caused a block signal, but this is easily modifiable, allowing different types of non-blocking tiles to be added as necessary.\par
\pard\keepn\nowidctlpar\s4\sb240\sa60\b\f1 2.5.2  levelMovement\par
\pard\nowidctlpar\sb60\qj\b0\f2 Not a separate module, but instead a section within main_state_machine, we implemented an up-down counter that, in response to push keys, would either increment or decrement, changing the background offset, and in essence, move the character horizontally across the level.\par
\pard\keepn\nowidctlpar\s4\sb240\sa60\b\f1 2.5.3  characterMovement\par
\pard\nowidctlpar\sb60\qj\b0\f2 A source of great frustration, characterMovement was intended to control the falling and jumping activities of the character. It was intended that a register would hold the y-position of the character, and would be constantly decremented to simulate falling, unless of course the character was blocked beneath. Jumping would consist of adding the output of a time-decrementing counter to the y-position register. Unfortunately, characterMovement was still buggy when we ran out of time, and instead, up-down character movement was implemented by an updown counter within main_state_machine, just like levelMovement.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.6  Scoring\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 Scoring, as implemented, is a second-by-second counter that outputs a decimal number to the hex displays. Since there is no ending to the game as implemented, the counter effectively counts up indefinitely from each reset.\par
\pard\keepn\nowidctlpar\s3\sb240\sa60\b\f1\fs32 2.7  bmp2mif\par
\pard\nowidctlpar\sb60\qj\b0\f2\fs24 Although not properly part of the circuit, it should be mentioned that we modified and extended the bmp2mif code to create 9-bit and 4-bit MIF files, which were used for our tiles and tilemap respectively.  By increasing the bit-depth of the MIF files, we were able to support vibrant 512-colour tiles, as well as up to 16 different types of tiles.  The design as presented, however, only made use of 8 different tiles.\par
\pard\keepn\nowidctlpar\s2\sb240\sa60\b\f1\fs32 2.8  Simplified Block Diagram:\par
\pard\nowidctlpar\b0\f2\fs24\par
\pard\nowidctlpar\sa120\b\fs32 3  Report on Success:\f3\par
\pard\sa120\b0\f4\fs24\par
\b\f5\fs32 3.1 Level Drawing and Scrolling\par
\b0\f4\fs24 We were able to complete this fundamental project milestone. Since this code would form the backbone of our project, it was important that level drawing and scrolling functioned properly and without bugs.  We were able to load the level tilemap from memory, and based on the value of our position counter, draw the appropriate tiles on the screen. By pressing the keys on the DE2, it was possible to scroll the level, tile by tile, both forwards and backwards, simulating character movement.\par
A possible next step in terms of level scrolling would be to scroll pixel by pixel instead of tile by tile (which meant that the level essentially scrolled 8 pixels at a time). This would have improved the appearance of the scrolling animation, and also given the level a higher physical resolution in terms of the character's position. Although code was written to perform this functionality, we were unable to fully debug it in time for the final presentation. We speculate that the root cause of the bugs was due to incompatibilities between our screen drawing algorithm and pixel-based scrolling.\par
\b\f5\fs32 3.2 Character Movement and Level Traversal\par
\b0\f4\fs24 The next milestone in our timeline was to allow character movement and level traversal. This meant the ability to jump over obstacles, move across the level, and be subject to an imposed gravity. In addition, it was necessary to draw the character on the screen.\par
The first two tasks were achieved, however we couldn't get gravity modeling to work. Thus, the character was able to move across the screen in all four directions, but wouldn't fall to the ground after jumping. The mostly likely cause of this is a faulty state machine within the characterMovement module, which was to control the character's Y position.\par
\b\f5\fs32 3.3 Enemies, Items, and other Fancy Features\par
\b0\f4\fs24 Essentially, we were able to write the code for most of the features listed in the milestones, but despite the fact that many of our individual modules seemed to work properly in simulation, they failed when connected to the main state machine for testing on the DE2.  Ultimately, we ran out of time: we had the code, but we just didn't have enough time to fix all the bugs.\par
Of the features that we planned for the third milestone, we were only able to get character animation working. That is, the character could face both left and right, and had two animation states: jumping and standing. Pressing the left and right keys would determine the direction the character was facing, and whether or not a jumping animation was shown was determined by whether or not the character was standing on a tile.\par
We had also planned introduction, win, and lose screens, which would have been shown at the start and end of the game. Unfortunately, despite the fact drawScreen was written, and we had screens prepared, we simply ran out of time.  Although merging these functions should have been trivial, it simply was another casualty of the time crunch.\par
\par
\b\f5\fs32 4  Conclusions\par
\b0\f4\fs24 What would we do differently next time?\par
\par
}
 